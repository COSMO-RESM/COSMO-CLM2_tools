#+TITLE: COSMO_CLM^2 simulation setup tools
#+AUTHOR: Matthieu Leclair
#+EXPORT_FILE_NAME: README
#+STARTUP: overview

Tools for automated creation and run of COSMO_CLM2 simulations

* Install
  - Install COSMO_CLM2_tools
    #+BEGIN_SRC shell
      git clone https://github.com/COSMO-RESM/COSMO_CLM2_tools.git
      cd COSMO_CLM2_tools
      python2 setup.py install --user
    #+END_SRC
  - Make sure =~/.local/bin= is in your path

* Usage
  More comprehensive help will come. Essentially the tool provides
  the cc2_create_case command. This is the result of =cc2_create_case
  --help=:
  #+BEGIN_SRC text
    usage: cc2_create_case [-h] [--machine MACH] [-s FILE] [--name NAME]
                           [--path PATH] [--cosmo_only COSMO_ONLY]
                           [--start_date DATE_1] [--end_date DATE_2]
                           [--run_length dt] [--cos_in COS_IN] [--cos_nml COS_NML]
                           [--cos_exe COS_EXE] [--cesm_in CESM_IN]
                           [--cesm_nml CESM_NML] [--cesm_exe CESM_EXE]
                           [--oas_in OAS_IN] [--oas_nml OAS_NML] [--ncosx NCOSX]
                           [--ncosy NCOSY] [--ncosio NCOSIO] [--ncesm NCESM]
                           [--gpu_mode GPU_MODE] [--dummy_day DUMMY_DAY]
                           [--wall_time WALL_TIME] [--account ACCOUNT]
                           [--partition PARTITION]
                           [--modules_opt {switch,none,purge}]
                           [--pgi_version {16.9.0,17.5.0,17.10.0, 18.5.0}]
                           [--shebang SHEBANG] [--no_submit] [--gen_oasis]

    Set up and run a COSMO_CLM2 case
    --------------------------------
    Options can be set up either by xml file or the following command line arguments.
    xml file options must be stored in a subelement of the root element tagged with 'main'.
    and/or the specific machine (see https://github.com/COSMO-RESM/COSMO_CLM2_tools/blob/master/COSMO_CLM2_tools/default_setup.xml)
    Command line arguments have precedence over xml file ones.

    optional arguments:
      -h, --help            show this help message and exit

    main:
      Options common to all machines

      --machine MACH        machine on which the case is running (default: has to be given
                            either by the command line or the xml setup file)
      -s FILE, --setup-file FILE
                            xml file conatining setup options
      --name NAME           case name (default: 'COSMO_CLM2')
      --path PATH           directory where the case is set up (default: $SCRATCH/NAME on daint)
      --cosmo_only COSMO_ONLY
                            run only cosmo with build-in soil model TERRA (default: False)
                            Be carefull to provide a COSMO executable compiled accordingly
      --start_date DATE_1   simulation start date formatted as YYYY-MM-DD-HH
      --end_date DATE_2     simulation end date formatted as YYYY-MM-DD-HH
      --run_length dt       sets simulation length if end_date not specified or run length
                            between restarts otherwise
                            dt is of the form 'N1yN2m' or 'N1y' or 'N2m' or 'N3d'
                            N1, N2 and N3 being arbitrary integers (N2>12 possible) and
                            'y', 'm' and 'd' stand for year, month and day
      --cos_in COS_IN       COSMO input files directory (default: './COSMO_input')
      --cos_nml COS_NML     COSMO namelists directory (default: './COSMO_nml')
      --cos_exe COS_EXE     path to COSMO executable (default: './cosmo')
      --cesm_in CESM_IN     CESM input files directory (default: './CESM_input')
      --cesm_nml CESM_NML   CESM namelists directory (default: './CESM_nml')
      --cesm_exe CESM_EXE   CESM executable (default: './cesm.exe')
      --oas_in OAS_IN       OASIS input files directory (default: './OASIS_input')
      --oas_nml OAS_NML     OASIS namelists directory (default: './OASIS_nml')
      --ncosx NCOSX         number of subdomains along the 'x-axis'
                            for COSMO domain decomposition (type: int, default: from INPUT_ORG namelist)
      --ncosy NCOSY         number of subdomains along the 'y-axis'
                            for COSMO domain decomposition (type: int, default: from INPUT_ORG namelist)
      --ncosio NCOSIO       number of cores dedicated to i/o work'
                            (type: int, default: from INPUT_ORG namelist)
      --ncesm NCESM         number of subdomains for CESM domain decomposition'
                            (type: int, default: from drv_in namelist)
      --gpu_mode GPU_MODE   run COSMO on gpu (type: bool, using anything Python can parse as a boolean,
                            default: False)
      --dummy_day DUMMY_DAY
                            perform a dummy day run after end of simulation to get last COSMO output.
                            (type: bool, using anything Python can parse as a boolean, default: True)

    slurm:
      Options specific to the slurm workload manager

      --wall_time WALL_TIME
                            reserved time on compute nodes
                            (default: '24:00:00' on daint, '08:00:00' on mistral)
      --account ACCOUNT     account to use for batch script
                            (default: infered from $PROJECT on daint, None on mistral)
      --partition PARTITION
                            select a queue (default: None)

    daint:
      Options specific to the Piz Daint machine

      --modules_opt {switch,none,purge}
                            Option for loading modules at run time (default: 'switch')
      --pgi_version {16.9.0,17.5.0,17.10.0, 18.5.0}
                            specify pgi compiler version at run time (default: None)
      --shebang SHEBANG     submit script shebang (default: '#!/usr/bin/env bash')

    cmd line:
      Options only avialble to the command line (no xml)

      --no_submit           do not submit job after setup
                            only command line argument, cannot be set in xml file
      --gen_oasis           generate OASIS auxiliary files
                            note that OASIS will crash after producing the files
                            only command line argument, cannot be set in xml file
  #+END_SRC
* COSMO_CLM2_tools                                                 :noexport:
  - [ ] Add doc strings
** default_setup.xml
   #+BEGIN_SRC nxml :tangle COSMO_CLM2_tools/default_setup.xml
     <?xml version="1.0" encoding="utf-8"?>
     <setup>
       <!-- main and machine specific options can also be set through the command line.
            Command line takes precedence -->
       <main>
         <name>COSMO_CLM2</name>
         <path></path>
         <cosmo_only></cosmo_only>
         <start_date></start_date>
         <end_date></end_date>
         <run_length></run_length>
         <cos_in>./COSMO_input</cos_in>
         <cos_nml>./COSMO_nml</cos_nml>
         <cos_exe>./cosmo</cos_exe>
         <cesm_in>./CESM_input</cesm_in>
         <cesm_nml>./CESM_nml</cesm_nml>
         <cesm_exe>./cesm.exe</cesm_exe>
         <oas_in>./OASIS_input</oas_in>
         <oas_nml>./OASIS_nml</oas_nml>
         <ncosx type="int"></ncosx>
         <ncosy type="int"></ncosy>
         <ncosio type="int"></ncosio>
         <ncesm type="int"></ncesm>
         <gpu_mode type="py_eval">False</gpu_mode>
         <dummy_day type="py_eval">True</dummy_day>
       </main>
       <daint>
         <wall_time>24:00:00</wall_time>
         <account></account>
         <partition></partition>
         <modules_opt>switch</modules_opt>
         <pgi_version></pgi_version>
         <shebang>#!/usr/bin/env bash</shebang>
       </daint>
       <mistral>
         <wall_time>08:00:00</wall_time>
         <account></account>
         <partition></partition>
       </mistral>
       <!-- Any namelist parameter can be changed by adding a <change_par> node directly under the <setup> node
            with attributes following this example
            <change_par file="INPUT_ORG" block="runctl" param="lreproduce" type="py_eval">True</change_par>
            - The value of the node is the new value of the namelist parameter
            - don't give the namelist file path, only the file name is needed.
            - type attribute can be any of the valid python types or "py_eval", in which case python
              will interpret the value. the default type is string
            - an "n" attribute starting at 1 (not 0) can also be given to target one of several blocks
              sharing the same name in a namelist, e.g. "gribout" blocks in INPUT_IO.
       -->
       <!-- In the same way, any namelist parameter can be deleted by adding an
            empty <del_par> node directly under the <setup> node with attributes following this example
            <del_par file="INPUT_ORG" block="runctl" param="lreproduce" />
            - don't give the namelist file path, only the file name is needed.
            - an "n" attribute starting at 1 (not 0) can also be given to target one of several blocks
              sharing the same name in a namelist, e.g. "gribout" blocks in INPUT_IO.
            - Obviouly any value given to that node is ignored
       -->
     </setup>
   #+END_SRC
** cc2_case.py
   :PROPERTIES:
   :header-args: :tangle COSMO_CLM2_tools/cc2_case.py :comments no
   :END:
*** preamble
    #+BEGIN_SRC python
      from __future__ import print_function
      from .tools import date_fmt, add_time_from_str
      from subprocess import check_call
      from argparse import ArgumentParser, RawTextHelpFormatter
      import f90nml
      from datetime import datetime, timedelta
      import os
      import re
      import xml.etree.ElementTree as ET
      from glob import glob
      import shutil
      import time
      import sys

      available_cases = {}
    #+END_SRC
*** case factory function
    #+BEGIN_SRC python
      def factory(machine, **case_args):
          if machine not in available_cases:
              raise ValueError("machine {:s} not available".format(machine))
          else:
              return available_cases[machine](**case_args)
    #+END_SRC
*** cc2_case (base) class
    - [ ] Add option for "user defined" batch script. Not full freedom
      can be given, still need to use =cc2_control_case=
    #+BEGIN_SRC python
      class cc2_case(object):
          """Base class defining a COSMO-CLM2 case"""

          _target_machine = None
          _n_tasks_per_node = None
          _default_install_dir = None
          NotImplementMessage = "required method {:s} not implemented by class {:s}.\n" \
                                "Implement with a single pass statement if irrelevant to this machine."


          def __init__(self, name='COSMO_CLM2', install_dir=None, install=False,
                       cos_nml='./COSMO_nml', cos_in='./COSMO_input', cos_exe='./cosmo',
                       cesm_nml='./CESM_nml', cesm_in='./CESM_input', cesm_exe='./cesm.exe',
                       oas_in='./OASIS_input', oas_nml='./OASIS_nml',
                       start_date=None, end_date=None, run_length=None,
                       ncosx=None, ncosy=None, ncosio=None, ncesm=None,
                       gpu_mode=False, dummy_day=True, cosmo_only=False,
                       gen_oasis=False):

              self.cosmo_only = cosmo_only
              # Create namelists dictionnary
              self.nml = nmldict(self)
              # Set case name, install_dir and path
              self._name = name
              self.install_dir = install_dir   # also sets self._path
              # Install: transfer namelists, executables and input files
              self.cos_in = os.path.abspath(cos_in)
              if install:
                  log = 'Setting up case {:s} in {:s}'.format(self._name, self._path)
                  print(log + '\n' + '-' * len(log))
                  self.install_case(cos_nml, cos_in, cos_exe, cesm_nml, cesm_in, cesm_exe, oas_nml, oas_in)
                  # Setting case name in namelist not possible before actually transfering the namelists
                  self.nml['drv_in']['seq_infodata_inparm']['case_name'] = self.name
              self.cos_exe = cos_exe
              if not self.cosmo_only:
                  self.cesm_exe = cesm_exe
              # Basic init (no particular work required)
              self.gen_oasis = gen_oasis
              self.run_length = run_length
              self.gpu_mode = gpu_mode
              self.dummy_day = dummy_day
              # Settings involving namelist changes
              self.start_date = start_date
              self.end_date = end_date
              self._compute_run_dates()   # defines _run_start_date, _run_end_date and _runtime (maybe _end_date)
              self._apply_run_dates()
              self._check_gribout()
              self._organize_tasks(ncosx, ncosy, ncosio, ncesm)
              # Finish install
              if install:
                  # Transfer COSMO input files
                  # - ML - Change this in future versions: only transfer the first chunck of input files
                  self.transfer_cos_in(self.start_date, self.end_date)
                  # Create batch script
                  self._build_controller()
                  # Create missing directories
                  self._create_missing_dirs()
              # Write namelists object to file
              self.write_open_nml()


          @property
          def cos_exe(self):
              return self._cos_exe
          @cos_exe.setter
          def cos_exe(self, exe_path):
              self._cos_exe = os.path.basename(exe_path)

          @property
          def cesm_exe(self):
              return self._cesm_exe
          @cesm_exe.setter
          def cesm_exe(self, exe_path):
              self._cesm_exe = os.path.basename(exe_path)

          @property
          def install_dir(self):
              return self._install_dir
          @install_dir.setter
          def install_dir(self, ins_dir):
              if ins_dir is None:
                  if self._default_install_dir is None:
                      raise NotImplementedError("_default_install_dir class variable not set for Class {:s}".format(cls.__name__))
                  else:
                      self._install_dir = self._default_install_dir
              else:
                  self._install_dir = ins_dir
              # Make install_dir absolute
              self._install_dir = os.path.abspath(self._install_dir)
              # Set case path
              self._path = os.path.join(self._install_dir, self.name)

          @property
          def path(self):
              return self._path

          @property
          def name(self):
              return self._name

          @property
          def start_date(self):
              return self._start_date
          @start_date.setter
          def start_date(self, start_date):
              if start_date is not None:
                  self._start_date = datetime.strptime(start_date, date_fmt['in'])
                  self.nml['INPUT_ORG']['runctl']['ydate_ini'] = self._start_date.strftime(date_fmt['cosmo'])
              elif 'ydate_ini' in self.nml['INPUT_ORG']['runctl'].keys():
                  self._start_date = datetime.strptime(self.nml['INPUT_ORG']['runctl']['ydate_ini'],
                                                       date_fmt['cosmo'])
              else:
                  raise ValueError("ydate_ini has to be given in INPUT_ORG/runctl if no start_date is provided")

          @property
          def end_date(self):
              return self._end_date
          @end_date.setter
          def end_date(self, end_date):
              if end_date is not None:
                  self._end_date = datetime.strptime(end_date, date_fmt['in'])
                  self.nml['INPUT_ORG']['runctl']['ydate_end'] = self._end_date.strftime(date_fmt['cosmo'])
              elif 'ydate_end' in self.nml['INPUT_ORG']['runctl'].keys():
                  self._end_date = datetime.strptime(self.nml['INPUT_ORG']['runctl']['ydate_end'], date_fmt['cosmo'])
              else:
                  self._end_date = None


          def install_case(self, cos_nml, cos_in, cos_exe, cesm_nml, cesm_in, cesm_exe, oas_nml, oas_in):
              if not os.path.exists(self.path):
                  # Create case directory
                  os.makedirs(self.path)

              # Transfer everything except COSMO input files
              check_call(['rsync', '-avrL', os.path.abspath(cos_nml)+'/', self.path])
              check_call(['rsync', '-avrL', os.path.abspath(cos_exe), self.path])
              if not self.cosmo_only:
                  check_call(['rsync', '-avrL', os.path.abspath(cesm_in)+'/', os.path.join(self.path,'CESM_input')+'/'])
                  check_call(['rsync', '-avrL', os.path.abspath(cesm_nml)+'/', self.path])
                  check_call(['rsync', '-avrL', os.path.abspath(cesm_exe), self.path])


          def transfer_cos_in(self, start_date, end_date):
              # Set time interval between 2 intput files
              dh = self.nml['INPUT_IO']['gribin']['hincbound']
              delta = timedelta(seconds=dh*3600.0)
              # Set file extension
              ext = ''
              if 'yform_read' in self.nml['INPUT_IO']['ioctl']:
                  if self.nml['INPUT_IO']['ioctl']['yform_read'] == 'ncdf':
                      ext = '.nc'
              # Build file list to transfer
              with open('transfer_list', mode ='w') as t_list:
                  # - ML - later, only do this when installing case
                  self._check_COSMO_input('laf', start_date, ext, t_list)
                  cur_date = start_date
                  while cur_date <= end_date:
                      self._check_COSMO_input('lbfd', cur_date, ext, t_list)
                      cur_date += delta
              # Tranfer files
              check_call(['rsync', '-avrL', '--files-from', 'transfer_list',
                          self.cos_in+'/', os.path.join(self.path,'COSMO_input')+'/'])
              # Remove transfer list
              os.remove('transfer_list')


          def _check_COSMO_input(self, root, date, ext, file_list):
                    file_name = root + format(date.strftime(date_fmt['cosmo'])) + ext
                    if os.path.exists(os.path.join(self.cos_in, file_name)):
                        file_list.write(file_name + '\n')
                    else:
                        raise ValueError("input file {:s} is missing from {:s}".format(file_name, self.cos_in))


          def _organize_tasks(self, ncosx, ncosy, ncosio, ncesm):
              # COSMO tasks
              # -----------
              if ncosx is None:
                  self._ncosx = self.nml['INPUT_ORG']['runctl']['nprocx']
              else:
                  self._ncosx = ncosx
                  self.nml['INPUT_ORG']['runctl']['nprocx'] = ncosx
              if ncosy is None:
                  self._ncosy = self.nml['INPUT_ORG']['runctl']['nprocy']
              else:
                  self._ncosy = ncosy
                  self.nml['INPUT_ORG']['runctl']['nprocy'] = ncosy
              if ncosio is None:
                  self._ncosio = self.nml['INPUT_ORG']['runctl']['nprocio']
              else:
                  self._ncosio = ncosio
                  self.nml['INPUT_ORG']['runctl']['nprocio'] = ncosio
              self._ncos = self._ncosx * self._ncosy + self._ncosio
              # CESM tasks and number of nodes
              # ------------------------------
              if self.cosmo_only:
                  self._ncesm = 0
                  if self.gpu_mode:
                      self._n_nodes = self._ncos
                  else:
                      self._n_nodes = self._ncos // self._n_tasks_per_node
              else:
                  if self.gpu_mode:   # Populate nodes with CESM tasks except one
                      self._n_nodes = self._ncos
                      self._ncesm = self._n_nodes * (self._n_tasks_per_node - 1)
                  else:   # Determine number of CESM tasks and deduce number of nodes
                      if ncesm is None:
                          self._ncesm = self.nml['drv_in']['ccsm_pes']['lnd_ntasks']
                      else:
                          self._ncesm = ncesm
                      ntot = self._ncos + self._ncesm
                      if ntot % self._n_tasks_per_node != 0:
                          msg = "total number of tasks (ncosx x ncosy + ncosio + ncesm = {:d}) has to be divisible by {:d}"
                          raise ValueError(msg.format(ntot, self._n_tasks_per_node))
                      self._n_nodes = ntot // self._n_tasks_per_node
                  # Apply number of CESM tasks to all relevant namelist parameters
                  for comp in ['atm', 'cpl', 'glc', 'ice', 'lnd', 'ocn', 'rof', 'wav']:
                      self.nml['drv_in']['ccsm_pes']['{:s}_ntasks'.format(comp)] = self._ncesm
                  if self.gen_oasis:
                      self.nml['drv_in']['ccsm_pes']['atm_ntasks'] = 1


          def _compute_run_dates(self):
              # Access to namelists
              # -------------------
              INPUT_ORG = self.nml['INPUT_ORG']
              if not self.cosmo_only:
                  drv_in = self.nml['drv_in']
              # Read in _run_start_date
              # -----------------------
              date_cosmo = datetime.strptime(INPUT_ORG['runctl']['ydate_ini'], date_fmt['cosmo']) \
                           + timedelta(hours=INPUT_ORG['runctl']['hstart'])
              if not self.cosmo_only:
                  date_cesm = datetime.strptime(str(drv_in['seq_timemgr_inparm']['start_ymd']), date_fmt['cesm'])
                  if date_cosmo != date_cesm:
                      raise ValueError("start dates are not identical in COSMO and CESM namelists")
              self._run_start_date = date_cosmo
              # Compute _runtime and _run_end_date (possibly _end_date)
              # -------------------------------------------------------
              if self._end_date is not None:
                  if self._run_start_date > self._end_date:
                      raise ValueError("run sart date is larger than case end date")
                  elif self._run_start_date == self._end_date:
                      self._runtime = timedelta(days=1)
                      self._run_end_date = self._end_date + self._runtime
                  else:
                      if self.run_length is None:
                          self._run_end_date = self._end_date
                      else:
                          self._run_end_date = min(add_time_from_str(self._run_start_date, self.run_length),
                                                   self._end_date)
                      self._runtime = self._run_end_date - self._run_start_date
              else:
                  if self.run_length is None:
                      runtime_cosmo = (INPUT_ORG['runctl']['nstop'] + 1) * INPUT_ORG['runctl']['dt'] \
                                      - INPUT_ORG['runctl']['hstart'] * 3600.0
                      if not self.cosmo_only:
                          runtime_cesm = drv_in['seq_timemgr_inparm']['stop_n']
                          if runtime_cosmo != runtime_cesm:
                              raise ValueError("run lengths are not identical in COSMO and CESM namelists")
                      self._runtime = timedelta(seconds=runtime_cosmo)
                      self._run_end_date = self._run_start_date + self._runtime
                  else:
                      self._run_end_date = add_time_from_str(self._run_start_date, self.run_length)
                      self._runtime = self._run_end_date - self._run_start_date
                  self._end_date = self._run_end_date


          def _apply_run_dates(self):
              # Compute times
              hstart = (self._run_start_date - self.start_date).total_seconds() // 3600.0
              runtime_seconds = self._runtime.total_seconds()
              runtime_hours = runtime_seconds // 3600.0
              hstop = hstart + runtime_hours
              # Access to namelists
              INPUT_ORG = self.nml['INPUT_ORG']
              INPUT_IO = self.nml['INPUT_IO']
              if not self.cosmo_only:
                  drv_in = self.nml['drv_in']
              # adapt INPUT_ORG
              INPUT_ORG['runctl']['nstop'] = int(hstop * 3600.0 // INPUT_ORG['runctl']['dt']) - 1
              if 'hstop' in INPUT_ORG['runctl']:
                  del INPUT_ORG['runctl']['hstop']
              # adapt INPUT_IO
              for gribout in self._get_gribouts():
                  gribout['hcomb'][0:2] = hstart, hstop
              INPUT_IO['ioctl']['nhour_restart'] = [int(hstop), int(hstop), 24]
              if not self.cosmo_only:
                  # adapt drv_in
                  drv_in['seq_timemgr_inparm']['stop_n'] = int(runtime_seconds)
                  drv_in['seq_timemgr_inparm']['restart_n'] = int(runtime_seconds)
                  # adapt namcouple
                  with open(os.path.join(self.path, 'namcouple_tmpl'), mode='r') as f:
                      content = f.read()
                  content = re.sub('_runtime_', str(int(self._runtime.total_seconds())), content)
                  with open(os.path.join(self.path, 'namcouple'), mode='w') as f:
                      f.write(content)


          def _check_gribout(self):
              # Only keep gribout blocks that fit within runtime
              # (essentially to avoid crash for short tests)
              runtime_hours = self._runtime.total_seconds() // 3600.0
              gribouts_out = []
              gribouts_in = self._get_gribouts()
              for gribout in gribouts_in:
                  if runtime_hours >= gribout['hcomb'][2]:
                      gribouts_out.append(gribout)
              if gribouts_out:
                  self.nml['INPUT_IO']['gribout'] = gribouts_out
                  self.nml['INPUT_IO']['ioctl']['ngribout'] = len(gribouts_out)
              else:
                  if gribouts_in:
                      del self.nml['INPUT_IO']['gribout']


          def _get_gribouts(self):
              if 'gribout' not in self.nml['INPUT_IO'].keys():
                  return []
              else:
                  gribouts = self.nml['INPUT_IO']['gribout']
                  if not isinstance(gribouts, list):
                      gribouts = [gribouts]
                  return gribouts


          def write_open_nml(self):
              self.nml.write_all()


          def _create_missing_dirs(self):
              # COSMO
              # -----
              # input
              self._mk_miss_path(self.nml['INPUT_IO']['gribin']['ydirini'])
              self._mk_miss_path(self.nml['INPUT_IO']['gribin']['ydirbd'])
              # output
              for gribout in self._get_gribouts():
                  self._mk_miss_path(gribout['ydir'])
              self._mk_miss_path(self.nml['INPUT_IO']['ioctl']['ydir_restart_in'])
              self._mk_miss_path(self.nml['INPUT_IO']['ioctl']['ydir_restart_out'])
              # CESM
              # ----
              if not self.cosmo_only:
                  # timing
                  # - ML - remove if exists before creating
                  shutil.rmtree(os.path.join(self.path, self.nml['drv_in']['seq_infodata_inparm']['timing_dir']),
                                ignore_errors=True)
                  shutil.rmtree(os.path.join(self.path, self.nml['drv_in']['seq_infodata_inparm']['tchkpt_dir']),
                                ignore_errors=True)
                  self._mk_miss_path(self.nml['drv_in']['seq_infodata_inparm']['timing_dir'])
                  self._mk_miss_path(self.nml['drv_in']['seq_infodata_inparm']['tchkpt_dir'])
                  # input / output
                  for comp in ['atm', 'cpl', 'glc', 'ice', 'lnd', 'ocn', 'rof', 'wav']:
                      self._mk_miss_path(self.nml['{:s}_modelio.nml'.format(comp)]['modelio']['diri'])
                      self._mk_miss_path(self.nml['{:s}_modelio.nml'.format(comp)]['modelio']['diro'])


          def _mk_miss_path(self, rel_path):
              path = os.path.join(self.path, rel_path)
              if not os.path.exists(path):
                  print('Creating path ' + path)
                  os.makedirs(path)


          def _build_controller(self):
              """Place holder for _build_controller method to be implemented by machine specific classes."""

              raise NotImplementedError(NotImplementMessage.format('_build_controller(self)', self.__class__.__name__))


          def _update_xml_config(self, config):
              """Place holder for _update_xml_config method to be implemented by machine specific classes."""

              raise NotImplementedError(NotImplementMessage.format('_update_xml_config(self)', self.__class__.__name__))


          def to_xml(self, file_name='config.xml'):

              def indent(elem, level=0):
                  i = "\n" + level*"  "
                  if len(elem):
                      if not elem.text or not elem.text.strip():
                          elem.text = i + "  "
                      if not elem.tail or not elem.tail.strip():
                          elem.tail = i
                      for elem in elem:
                          indent(elem, level+1)
                      if not elem.tail or not elem.tail.strip():
                          elem.tail = i
                  else:
                      if level and (not elem.tail or not elem.tail.strip()):
                          elem.tail = i

              config = ET.Element('config')
              tree = ET.ElementTree(config)
              ET.SubElement(config, 'name').text = self.name
              ET.SubElement(config, 'install_dir').text = self.install_dir
              ET.SubElement(config, 'cosmo_only', type='py_eval').text = str(self.cosmo_only)
              ET.SubElement(config, 'gen_oasis', type='py_eval').text = str(self.gen_oasis)
              ET.SubElement(config, 'start_date').text = self.start_date.strftime(date_fmt['in'])
              ET.SubElement(config, 'end_date').text = self.end_date.strftime(date_fmt['in'])
              ET.SubElement(config, 'run_length').text = self.run_length
              ET.SubElement(config, 'cos_exe').text = self.cos_exe
              if not self.cosmo_only:
                  ET.SubElement(config, 'cesm_exe').text = self.cesm_exe
              ET.SubElement(config, 'cos_in').text = self.cos_in
              ET.SubElement(config, 'gpu_mode', type='py_eval').text = str(self.gpu_mode)
              ET.SubElement(config, 'dummy_day', type='py_eval').text = str(self.dummy_day)
              self._update_xml_config(config)
              indent(config)
              tree.write(os.path.join(self.path, file_name), xml_declaration=True)


          def set_next_run(self):
              if ((self._run_start_date >= self._end_date) or
                  (self._run_end_date == self._end_date and not self.dummy_day)):
                  continue_run = False
              else:
                  continue_run = True
                  hstart = (self._run_end_date - self._start_date).total_seconds() // 3600.0
                  self.nml['INPUT_ORG']['runctl']['hstart'] = hstart
                  if not self.cosmo_only:
                      self.nml['drv_in']['seq_timemgr_inparm']['start_ymd'] = int(self._run_end_date.strftime(date_fmt['cesm']))
                  self._compute_run_dates()
                  # - ML - Setting ydirini might not be needed, try without at some point
                  self.nml['INPUT_IO']['gribin']['ydirini'] = self.nml['INPUT_IO']['ioctl']['ydir_restart_out']
                  for gribout in self._get_gribouts():
                      gribout['lwrite_const'] = False
                  if not self.cosmo_only:
                      self.nml['drv_in']['seq_infodata_inparm']['start_type'] = 'continue'
                  self.write_open_nml()
                  self._update_controller()

              return continue_run


          def _update_controller(self):
              """Place holder for _update_controller method to be implemented by machine specific classes."""

              raise NotImplementedError(NotImplementMessage.format('_update_controller(self)', self.__class__.__name__))


          def submit(self):
              cwd = os.getcwd()
              os.chdir(self.path)
              self._submit_func()
              os.chdir(cwd)


          def run(self):
              start_time = time.time()
              cwd = os.getcwd()

              # Clean workdir
              os.chdir(self.path)
              file_list = glob('YU*') + glob('debug*') + glob('core*') + glob('nout.*') + glob('*.timers_*')
              for f in file_list:
                  os.remove(f)

              # Run
              self._run_func()

              os.chdir(cwd)
              elapsed = time.time() - start_time
              print("\nCase {name:s} ran in {elapsed:.2f}\n".format(name=self.name, elapsed=elapsed))


          def _run_func(self):
              """Place holder for _run_func method to be implemented by machine specific classes."""

              raise NotImplementedError(NotImplementMessage.format('_run_func(self)', self.__class__.__name__))


          def _submit_func(self):
              """Place holder for _submit_func method to be implemented by machine specific classes."""

              raise NotImplementedError(NotImplementMessage.format('_submit_func(self)', self.__class__.__name__))
    #+END_SRC
*** available case decorator
    #+BEGIN_SRC python
      def available(cls):
          if cls._target_machine is None:
              raise NotImplementedError("_target_machine class variable not set for Class {:s}".format(cls.__name__))
          else:
              available_cases[cls._target_machine] = cls
              return cls
    #+END_SRC

*** daint_case class
    #+BEGIN_SRC python
      @available
      class daint_case(cc2_case):
          """Class defining a COSMO-CLM2 case on Piz Daint"""

          _target_machine='daint'
          _n_tasks_per_node = 12
          _default_install_dir = os.path.normpath(os.environ['SCRATCH'])


          def __init__(self, wall_time='24:00:00', account=None, partition=None,
                       shebang='#!/bin/bash', modules_opt='switch', pgi_version=None,
                       ,**base_case_args):

              self.wall_time = wall_time
              self.account = account
              self.modules_opt = modules_opt
              self.pgi_version = pgi_version
              self.shebang = shebang
              self.partition = partition
              cc2_case.__init__(self, **base_case_args)

          @property
          def account(self):
              return self._account
          @account.setter
          def account(self, acc):
              if acc is None:
                  # Guess from ${PROJECT} environment variable
                  self._account = os.path.normpath(os.environ['PROJECT']).split(os.path.sep)[-2]
              else:
                  self._account = acc


          def _build_controller(self):

              logfile = '{:s}_{:s}-{:s}.out'.format(self.name,
                                                    self._run_start_date.strftime(date_fmt['cesm']),
                                                    self._run_end_date.strftime(date_fmt['cesm']))
              with open(os.path.join(self.path, 'controller'), mode='w') as script:
                  # shebang
                  script.write('{:s}\n\n'.format(self.shebang))

                  # slurm options
                  script.write('#SBATCH --constraint=gpu\n')
                  script.write('#SBATCH --job-name={:s}\n'.format(self.name))
                  script.write('#SBATCH --nodes={:d}\n'.format(self._n_nodes))
                  script.write('#SBATCH --output={:s}\n'.format(logfile))
                  script.write('#SBATCH --error={:s}\n'.format(logfile))
                  script.write('#SBATCH --account={:s}\n'.format(self.account))
                  script.write('#SBATCH --time={:s}\n'.format(self.wall_time))
                  script.write('#SBATCH --gres=gpu:1\n')
                  if self.partition is not None:
                      script.write('#SBATCH --partition={:s}\n'.format(self.partition))
                  script.write('\n')

                  # environment variables
                  script.write('export MALLOC_MMAP_MAX_=0\n')
                  script.write('export MALLOC_TRIM_THRESHOLD_=536870912\n')
                  script.write('\n')
                  script.write('# Set this to avoid segmentation faults\n')
                  script.write('ulimit -s unlimited\n')
                  script.write('ulimit -a\n')
                  script.write('\n')
                  script.write('export OMP_NUM_THREADS=1\n')
                  if self.gpu_mode:
                      script.write('\n')
                      script.write('# Use for gpu mode\n')
                      script.write('export MV2_ENABLE_AFFINITY=0\n')
                      script.write('export MV2_USE_CUDA=1\n')
                      script.write('export MPICH_G2G_PIPELINE=256\n')
                      if self.cosmo_only:
                          script.write('export MPICH_RDMA_ENABLED_CUDA=1\n')
                  script.write('\n')

                  # Modules
                  if self.modules_opt != 'none':
                      # pgi programing environment
                      if self.modules_opt == 'purge':
                          script.write('module purge\n')
                          script.write('module load PrgEnv-pgi\n')
                      elif self.modules_opt == 'switch':
                          script.write('module switch PrgEnv-cray PrgEnv-pgi\n')
                      # pgi version
                      if self.pgi_version is not None:
                          script.write('module unload pgi\n')
                          script.write('module load pgi/{:s}\n'.format(self.pgi_version))

                      # other modules
                      script.write('module load daint-gpu\n')
                      script.write('module load cray-netcdf\n')
                      if self.gpu_mode:
                          script.write('module load craype-accel-nvidia60\n')    
                      script.write('\n')

                  # launch case
                  script.write('cc2_control_case ./config.xml\n')


          def _update_controller(self):
              logfile = '{:s}_{:s}-{:s}.out'.format(self.name,
                                                    self._run_start_date.strftime(date_fmt['cesm']),
                                                    self._run_end_date.strftime(date_fmt['cesm']))
              rules = {'#SBATCH +--output=.*$': '#SBATCH --output={:s}'.format(logfile),
                       '#SBATCH +--error=.*$': '#SBATCH --error={:s}'.format(logfile)}
              with open(os.path.join(self.path, 'controller'), mode='r+') as f:
                  content = f.read()
                  for pattern, repl in rules.items():
                      content = re.sub(pattern, repl, content, flags=re.MULTILINE)
                  f.seek(0)
                  f.write(content)
                  f.truncate()


          def _update_xml_config(self, config):
              ET.SubElement(config, 'machine').text = 'daint'
              ET.SubElement(config, 'account').text = self.account
              ET.SubElement(config, 'wall_time').text = self.wall_time
              ET.SubElement(config, 'partition').text = self.partition
              ET.SubElement(config, 'modules_opt').text = self.modules_opt
              ET.SubElement(config, 'pgi_version').text = self.pgi_version
              ET.SubElement(config, 'shebang').text = str(self.shebang)


          def _submit_func(self):
              check_call(['sbatch', 'controller'])


          def _run_func(self):
              # Determine run command
              if self.cosmo_only:
                  if self.gpu_mode:
                      run_cmd = 'srun -u --ntasks-per-node=1 -n {:d} {:s}'.format(self._n_nodes, self.COSMO_exe)
                  else:
                      run_cmd = 'srun -u -n {:d} {:s}'.format(self._n_nodes * self._n_tasks_per_node, self.COSMO_exe)
              else:
                  self._build_proc_config()
                  run_cmd = 'srun -u --multi-prog ./proc_config'

              # Run
              check_call(['module list'], shell=True)
              print("running " + run_cmd)
              sys.stdout.flush()
              check_call(run_cmd, shell=True)


          def _build_proc_config(self):

              # Build executable bash files
              f_path = os.path.join(self.path, 'cosmo.bash')
              with open(f_path, 'w') as f:
                  f.write("#!/bin/bash\n")
                  f.write("export MPICH_RDMA_ENABLED_CUDA={:1d}\n".format(self.gpu_mode))
                  f.write("./{:s}".format(self.cos_exe))
              os.chmod(f_path, 0o755)
              f_path = os.path.join(self.path, 'cesm.bash')
              with open(f_path, 'w') as f:
                  f.write("#!/bin/bash\n")
                  f.write("export MPICH_RDMA_ENABLED_CUDA=0\n")
                  f.write("./{:s}".format(self.cesm_exe))
              os.chmod(f_path, 0o755)

              # Build proc_config
              with open(os.path.join(self.path, 'proc_config'), mode='w') as f:
                  if self.gpu_mode:
                      N = self._n_tasks_per_node
                      tasks = ",".join([str(k*N) for k in range(self._n_nodes)])
                      f.write("{:s} ./cosmo.bash\n".format(tasks))
                      tasks = ",".join(["{:d}-{:d}".format(k*N+1,(k+1)*N-1) for k in range(self._n_nodes)])
                      f.write("{:s} ./cesm.bash".format(tasks))
                  else:
                      f.write('{:d}-{:d} ./cosmo.bash\n'.format(0, self._ncos-1))
                      f.write('{:d}-{:d} ./cesm.bash'.format(self._ncos, self._ncos+self._ncesm-1))
    #+END_SRC

*** mistral_case class
    #+BEGIN_SRC python
      @available
      class mistral_case(cc2_case):
          """Class defining a COSMO-CLM2 case on Mistral"""

          _target_machine='mistral'
          _n_tasks_per_node = 24

          def __init__(self, wall_time='08:00:00', account=None, partition=None,
                       **base_case_args):
              self.wall_time = wall_time
              self.account = account
              self.partition = partition
              cc2_case.__init__(self, **base_case_args)
              if self.gpu_mode:
                  raise NotImplementedError("gpu mode not implemented for " + self.__class__.__name__)


          def _build_proc_config(self):
              with open(os.path.join(self.path, 'proc_config'), mode='w') as f:
                  f.write('{:d}-{:d} ./{:s}\n'.format(0, self._ncos-1, self.COSMO_exe))
                  if not self.cosmo_only:
                      f.write('{:d}-{:d} ./{:s}\n'.format(self._ncos, self._ncos+self._ncesm-1, self.CESM_exe))


          def _build_controller(self):
              logfile = '{:s}_{:s}-{:s}.out'.format(self.name,
                                                    self._run_start_date.strftime(date_fmt['cesm']),
                                                    self._run_end_date.strftime(date_fmt['cesm']))
              with open(os.path.join(self.path, 'controller'), mode='w') as script:
                  # shebang
                  script.write('#!/usr/bin/env bash\n')

                  # slurm options
                  script.write('#SBATCH --job-name={:s}\n'.format(self.name))
                  script.write('#SBATCH --nodes={:d}\n'.format(self._n_nodes))
                  script.write('#SBATCH --output={:s}\n'.format(logfile))
                  script.write('#SBATCH --error={:s}\n'.format(logfile))
                  script.write('#SBATCH --account={:s}\n'.format(self.account))
                  script.write('#SBATCH --time={:s}\n'.format(self.wall_time))
                  if self.partition is not None:
                      script.write('#SBATCH --partition={:s}\n'.format(self.partition))
                  script.write('\n')

                  # environment variables
                  script.write('export LD_LIBRARY_PATH=/sw/rhel6-x64/netcdf/netcdf_fortran-4.4.3-parallel-openmpi2-intel14/lib/:/sw/rhel6-x64/netcdf/parallel_netcdf-1.6.1-openmpi2-intel14/lib\n')
                  script.write('\n')
                  script.write('# Set this to avoid segmentation faults\n')
                  script.write('ulimit -s unlimited\n')
                  script.write('ulimit -a\n')
                  script.write('\n')
                  script.write('export OMP_NUM_THREADS=1\n')
                  script.write('\n')

                  # launch case
                  script.write('cc2_control_case ./config.xml\n')


          def _update_controller(self):
              logfile = '{:s}_{:s}-{:s}.out'.format(self.name,
                                                    self._run_start_date.strftime(date_fmt['cesm']),
                                                    self._run_end_date.strftime(date_fmt['cesm']))
              rules = {'#SBATCH +--output=.*$': '#SBATCH --output={:s}'.format(logfile),
                       '#SBATCH +--error=.*$': '#SBATCH --error={:s}'.format(logfile)}
              with open(os.path.join(self.path, 'controller'), mode='r+') as f:
                  content = f.read()
                  for pattern, repl in rules.items():
                      content = re.sub(pattern, repl, content, flags=re.MULTILINE)
                  f.seek(0)
                  f.write(content)
                  f.truncate()


          def _update_xml_config(self, config):
              ET.SubElement(config, 'machine').text = 'mistral'
              ET.SubElement(config, 'account').text = self.account
              ET.SubElement(config, 'wall_time').text = self.wall_time
              ET.SubElement(config, 'partition').text = self.partition


          def _submit_func(self):
              check_call(['sbatch', 'controller', './config.xml'])


          def _run_func(self):
              if self.cosmo_only:
                  run_cmd = 'srun -u -n {:d} {:s}'.format(self._n_nodes * self._n_tasks_per_node, self.COSMO_exe)
              else:
                  self._build_proc_config()
                  run_cmd = 'srun -u --multi-prog ./proc_config'
              print("running " + run_cmd)
              sys.stdout.flush()
              check_call(run_cmd, shell=True)
    #+END_SRC
*** nmldict class
    #+BEGIN_SRC python
      class nmldict(dict):
          """Dictionnary of all the namelists of a case. Only load the namelist if needed"""
          def __init__(self, cc2case):
              dict.__init__(self)
              self.cc2case = cc2case

          def __getitem__(self, key):
              if key not in self:
                  self[key] = f90nml.read(os.path.join(self.cc2case.path, key))
              return dict.__getitem__(self, key)

          def write(self, name):
              self[name].write(os.path.join(self.cc2case.path, name), force=True)

          def write_all(self):
              for name in self:
                  self.write(name)
    #+END_SRC

** create_case.py
   :PROPERTIES:
   :header-args: :tangle COSMO_CLM2_tools/create_case.py :comments no
   :END:
*** preamble
    #+BEGIN_SRC python
      from __future__ import print_function
      from .cc2_case import factory as cc2_case_factory, available_cases
      from .tools import date_fmt, get_xml_node_args
      from subprocess import check_call
      from argparse import ArgumentParser, RawTextHelpFormatter, Action as arg_action
      import f90nml
      from datetime import datetime, timedelta
      import os
      import xml.etree.ElementTree as ET
      import shutil
    #+END_SRC
*** create_case
    - [ ] For now, no choice for the I/O directory structure. Maybe no
      need to implement this.
    #+BEGIN_SRC python
      def create_case():
          """
          Create a Cosmo-CLM2 case from cmd line arguments and xml setup file

          See ``cc2_create_case --help``
          """

          # Build command line parser
          # =========================

          # Custom action factory to fill in cc2_cmd_args dictionnary
          cc2_cmd_args = {}
          case_actions = {}

          def cc2_act(*groups):

              for group in groups:
                  if group not in cc2_cmd_args:
                      cc2_cmd_args[group] = {}

              key = '.'.join(groups)

              if key not in case_actions:
                  def call(self, parser, args, values, option_string=None):
                      for group in self.cc2_groups:
                          cc2_cmd_args[group][self.dest] = values
                  name = 'cc2_' + '_'.join(groups)
                  case_actions[key] = type(name, (arg_action,),{'__call__': call, 'cc2_groups': groups})

              return case_actions[key]

          # function for boolean type
          def str_to_bool(val_str):
              return bool(eval(val_str))

          # Create parser
          dsc = "Set up and run a COSMO_CLM2 case\n"\
                "--------------------------------\n"\
                "Options can be set up either by xml file or the following command line arguments.\n"\
                "xml file options must be stored in a subelement of the root element tagged with 'main'.\n"\
                "and/or the specific machine (see https://github.com/COSMO-RESM/COSMO_CLM2_tools/blob/master/COSMO_CLM2_tools/default_setup.xml)\n"\
                "Command line arguments have precedence over xml file ones."
          parser = ArgumentParser(description=dsc, formatter_class=RawTextHelpFormatter)
          main_group = parser.add_argument_group('main', 'Options common to all machines')
          main_group.add_argument('--machine', metavar='MACH', action=cc2_act('main'),
                                  help="machine on which the case is running (default: has to be given \n"\
                                  "either by the command line or the xml setup file)")
          main_group.add_argument('-s', '--setup-file', metavar='FILE', help="xml file conatining setup options")
          main_group.add_argument('--name', action=cc2_act('main'), help="case name (default: COSMO_CLM2)")
          main_group.add_argument('--install_dir', action=cc2_act('main'),
                                  help="directory where the case is installed (default: $SCRATCH on daint)")
          main_group.add_argument('--cosmo_only', action=cc2_act('main'), type=str_to_bool,
                                  help="run only cosmo with build-in soil model TERRA\n"\
                                  "(type: bool, using anything Python can parse as a boolean, default: False)\n"\
                                  "Be carefull to provide a COSMO executable compiled accordingly")
          main_group.add_argument('--start_date', metavar='DATE_1', action=cc2_act('main'),
                                  help="simulation start date formatted as YYYY-MM-DD-HH")
          main_group.add_argument('--end_date', metavar='DATE_2', action=cc2_act('main'),
                                  help="simulation end date formatted as YYYY-MM-DD-HH")
          main_group.add_argument('--run_length', metavar='dt', action=cc2_act('main'),
                                  help="sets simulation length if end_date not specified or run length\n"\
                                  "between restarts otherwise\n"\
                                  "dt is of the form 'N1yN2m' or 'N1y' or 'N2m' or 'N3d'\n"\
                                  "N1, N2 and N3 being arbitrary integers (N2>12 possible) and\n"\
                                  "'y', 'm' and 'd' stand for year, month and day")
          main_group.add_argument('--cos_in', action=cc2_act('main'),
                                  help="COSMO input files directory (default: ./COSMO_input)")
          main_group.add_argument('--cos_nml', action=cc2_act('main'),
                                  help="COSMO namelists directory (default: ./COSMO_nml)")
          main_group.add_argument('--cos_exe', action=cc2_act('main'),
                                  help="path to COSMO executable (default: ./cosmo)")
          main_group.add_argument('--cesm_in', action=cc2_act('main'),
                                  help="CESM input files directory (default: ./CESM_input)")
          main_group.add_argument('--cesm_nml', action=cc2_act('main'),
                                  help="CESM namelists directory (default: ./CESM_nml)")
          main_group.add_argument('--cesm_exe', action=cc2_act('main'),
                                  help="CESM executable (default: ./cesm.exe)")
          main_group.add_argument('--oas_in', action=cc2_act('main'),
                                  help="OASIS input files directory (default: ./OASIS_input)")
          main_group.add_argument('--oas_nml', action=cc2_act('main'),
                                  help="OASIS namelists directory (default: ./OASIS_nml)")
          main_group.add_argument('--ncosx', action=cc2_act('main'), type=int,
                                  help="number of subdomains along the 'x-axis'\n"\
                                  "for COSMO domain decomposition (type: int, default: from INPUT_ORG namelist)")
          main_group.add_argument('--ncosy', action=cc2_act('main'), type=int,
                                  help="number of subdomains along the 'y-axis'\n"\
                                  "for COSMO domain decomposition (type: int, default: from INPUT_ORG namelist)")
          main_group.add_argument('--ncosio', action=cc2_act('main'), type=int,
                                  help="number of cores dedicated to i/o work'\n"\
                                  "(type: int, default: from INPUT_ORG namelist)")
          main_group.add_argument('--ncesm', action=cc2_act('main'), type=int,
                                  help="number of subdomains for CESM domain decomposition'\n"\
                                  "(type: int, default: from drv_in namelist)")
          main_group.add_argument('--gpu_mode', action=cc2_act('main'), type=str_to_bool,
                                  help="run COSMO on gpu (type: bool, using anything Python can parse as a boolean,\n"\
                                  "default: False)")
          main_group.add_argument('--dummy_day', action=cc2_act('main'), type=str_to_bool,
                                  help="perform a dummy day run after end of simulation to get last COSMO output.\n"\
                                  "(type: bool, using anything Python can parse as a boolean, default: True)")

          slurm_group = parser.add_argument_group('slurm', 'Options specific to the slurm workload manager.\n'\
                                                  '(common to all machines using the slurm scheduler)')
          slurm_group.add_argument('--wall_time', action=cc2_act('daint', 'mistral'),
                                   help="reserved time on compute nodes\n"\
                                   "(default: '24:00:00' on daint, '08:00:00' on mistral)")
          slurm_group.add_argument('--account', action=cc2_act('daint', 'mistral'),
                                   help="account to use for batch script\n"\
                                   "(default: infered from $PROJECT on daint, None on mistral)")
          slurm_group.add_argument('--partition', action=cc2_act('daint', 'mistral'),
                                   help="select a queue (default: None)")

          daint_group = parser.add_argument_group('daint', 'Options specific to the Piz Daint machine')
          daint_group.add_argument('--modules_opt', action=cc2_act('daint'), choices=['switch', 'none', 'purge'],
                                   help="Option for loading modules at run time (default: switch)")
          daint_group.add_argument('--pgi_version', action=cc2_act('daint'),
                                   help="specify pgi compiler version at run time (default: None)")
          daint_group.add_argument('--shebang', action=cc2_act('daint'),
                                   help="submit script shebang (default: #!/usr/bin/env bash)")

          cmd_line_group = parser.add_argument_group('cmd line', 'Options only avialble to the command line (no xml)')
          cmd_line_group.add_argument('--no_submit', action='store_false', dest='submit',
                                      help="do not submit job after setup\n"\
                                      "only command line argument, cannot be set in xml file")
          cmd_line_group.add_argument('--gen_oasis', action='store_true',
                                      help="generate OASIS auxiliary files\n"\
                                      "note that OASIS will crash after producing the files\n"\
                                      "only command line argument, cannot be set in xml file\n")

          opts = parser.parse_args()

          # Parse machine and case argumennts from cmd line args and xml file
          # =================================================================
          machine, cc2_args = get_case_args(opts, cc2_cmd_args)
          print('- ML - DBG: cc2_args = ', cc2_args)

          # Create case instance
          # ====================
          cc2case = cc2_case_factory(machine, **cc2_args)

          # Change/delete namelists parameters following xml file
          # =====================================================
          modify_nml_from_xml(cc2case, opts)

          # Finalize
          # ========
          cc2case.write_open_nml()
          cc2case.to_xml(file_name='config.xml')

          # Submit case
          # ===========
          if opts.submit:
              cc2case.submit()
    #+END_SRC
*** get_case_args
    #+BEGIN_SRC python
      def get_case_args(cmd_opts, cc2_cmd_args):

          if cmd_opts.gen_oasis:
              cc2_cmd_args['main']['dummy_day'] = False

          if 'machine' in cc2_cmd_args['main']:
              machine = cc2_cmd_args['main']
          else:
              machine = None

          xml_file = cmd_opts.setup_file
          if xml_file:
              tree_root = ET.parse(xml_file).getroot()
              main_node = tree_root.find('main')
              if machine is None:
                  machine_name_node = main_node.find('machine')
                  if machine_name_node is not None:
                      machine = machine_name_node.text
              machine_node = tree_root.find(machine)

          if machine is None:
              raise ValueError("'machine' option has to be given either by the command line or the xml setup file")

          main_args = get_xml_node_args(main_node, exclude=('machine'))
          main_args.update(cc2_cmd_args['main'])

          machine_args = get_xml_node_args(machine_node)
          machine_args.update(cc2_cmd_args[machine])

          cc2_args = {k:v for k,v in main_args.items() if v is not None}
          cc2_args.update({k:v for k,v in machine_args.items() if v is not None})
          cc2_args['install'] = True

          return machine, cc2_args
    #+END_SRC
*** modify_nml_from_xml
    #+BEGIN_SRC python
      def modify_nml_from_xml(cc2case, cmd_opts):
          """Modify case namelists following instructions from xml setup file"""

          if cmd_opts.setup_file is None:
              return
    
          tree_root = ET.parse(cmd_opts.setup_file).getroot()

          # Change parameters
          nodes = tree_root.findall('change_par')
          if nodes:
              for node in nodes:
                  name = node.get('file')
                  block = node.get('block')
                  n = node.get('n')
                  param = node.get('param')
                  val_str = node.text
                  if name is None:
                      raise ValueError("'file' xml attribute is required to change parameter")
                  if block is None:
                      raise ValueError("'block' xml attribute is required to change parameter")
                  if param is None:
                      raise ValueError("'param' xml attribute is required to change parameter")
                  if node.get('type') is None:
                      value = val_str
                  elif node.get('type') == 'py_eval':
                      value = eval(val_str)
                  else:
                      val_type = eval(node.get('type'))
                      if isinstance(val_type, type):
                          value = val_type(val_str)
                      else:
                          err_mess = "Given xml atribute 'type' for parameter {:s} is {:s}\n"\
                                     "It has to be either 'py_eval' or a valid build in python type"
                          raise ValueError(err_mess.format(param, val_type))
                  if n is None:
                      cc2case.nml[name][block][param] = value
                  else:
                      cc2case.nml[name][block][int(n)-1][param] = value

          # Delete parameters
          nodes = tree_root.findall('del_par')
          if nodes:
              for node in nodes:
                  name = node.get('file')
                  block = node.get('block')
                  n = node.get('n')
                  param = node.get('param')
                  if name is None:
                      raise ValueError("'file' xml attribute is required to delete parameter")
                  if block is None:
                      raise ValueError("'block' xml attribute is required to delete parameter")
                  if param is None:
                      raise ValueError("'param' xml attribute is required to delete parameter")
                  if n is None:
                      del cc2case.nml[name][block][param]
                  else:
                      del cc2case.nml[name][block][int(n)-1][param]

    #+END_SRC
** control_case.py
   - [ ] The xml part of it could go to a bla_from_xml factory function
   #+BEGIN_SRC python :tangle COSMO_CLM2_tools/control_case.py :comments no
     from .cc2_case import factory as cc2_case_factory
     from .tools import get_xml_node_args
     from argparse import ArgumentParser, RawTextHelpFormatter
     import xml.etree.ElementTree as ET


     def control_case():
         # Parse arguments
         dsc = "Control a COSMO_CLM2 case"
         parser = ArgumentParser(description=dsc, formatter_class=RawTextHelpFormatter)
         parser.add_argument('xml_path', help="path to xml file containing case description")
         cfg = parser.parse_args()

         # build cc2case object from xml file
         config = ET.parse(cfg.xml_path).getroot()
         machine_node = config.find('machine')
         if machine_node is None:
             raise ValueError("machine node not found in {:s}".format(xml_file))
         machine = machine_node.text
         case_args = get_xml_node_args(config, exclude=('machine',))
         cc2case = cc2_case_factory(machine, **case_args)

         # Run
         cc2case.run()

         # Submit next run
         if cc2case.set_next_run():
             cc2case.submit()
   #+END_SRC

** tools.py
   #+BEGIN_SRC python :tangle COSMO_CLM2_tools/tools.py :comments no
     date_fmt = {'in': '%Y-%m-%d-%H', 'cosmo': '%Y%m%d%H','cesm': '%Y%m%d'}


     def add_time_from_str(date1, dt_str):
         """Increment date from a string

         Return the date resulting from date + N1 years + N2 months or date + N3 days
         where dt_str is a string of the form 'N1yN2m' or 'N1y' or 'N2m' or 'N3d',
         N1, N2 and N3 being arbitrary integers potentially including sign and
         'y', 'm' and 'd' the actual letters standing for year, month and day respectivly."""

         ky, km, kd, ny, nm, nd = 0, 0, 0, 0, 0, 0
         for k, c in enumerate(dt_str):
             if c == 'y':
                 ky, ny = k, int(dt_str[0:k])
             if c == 'm':
                 km, nm = k, int(dt_str[ky:k])

         if km == 0 and ky == 0:
             for k, c in enumerate(dt_str):
                 if c == 'd':
                     kd, nd = k, int(dt_str[0:k])
             if kd == 0:
                 raise ValueError("date increment '" + dt_str + "' doesn't have the correct format")
             else:
                 return date1 + timedelta(days=nd)
         else:
             y2, m2, d2, h2 = date1.year, date1.month, date1.day, date1.hour
             y2 += ny + (nm+m2-1) // 12
             m2 = (nm+m2-1) % 12 + 1
             return datetime(y2, m2, d2, h2)


     def get_xml_node_args(node, exclude=()):
         """Read case arguments from xml node"""

         if node is None:
             return {}

         xml_args = {}

         for opt in node.iter():
             if opt is not node and opt.tag not in exclude:
                 if opt.get('type') is None:
                     xml_args[opt.tag] = opt.text
                 elif opt.get('type') == 'py_eval':
                     xml_args[opt.tag] = eval(opt.text)
                 else:
                     opt_type = eval(opt.get('type'))
                     if isinstance(opt_type, type):
                         xml_args[opt.tag] = opt_type(opt.text)
                     else:
                         raise ValueError("xml atribute 'type' " + opt.get('type')
                                          + " for node " + opt.tag
                                          + " has to be a valid python type or 'py_eval'")

         return xml_args
   #+END_SRC
** __init__.py
   #+BEGIN_SRC python :tangle COSMO_CLM2_tools/__init__.py :comments no
     __version__ = '0.2'
   #+END_SRC

* setup.py                                                         :noexport:
  #+BEGIN_SRC python :tangle setup.py :comments no
    import os
    from setuptools import setup
    # try:
    #     from setuptools import setup
    # except ImportError:
    #     from distutils.core import setup

    def get_version():
        with open('COSMO_CLM2_tools/__init__.py') as f:
            for line in f:
                if line.startswith('__version__'):
                    _, _, version = line.replace("'", '').split()
                    break
        return version

    setup(name='COSMO_CLM2_tools',
          version=get_version(),
          description="python based tools to set up a COSMO_CLM2 case",
          author="Matthieu Leclair",
          author_email="matthieu.leclair@env.ethz.ch",
          url="https://github.com/COSMO-RESM/COSMO-CLM2_tools",
          packages=['COSMO_CLM2_tools'],
          entry_points={'console_scripts': ['cc2_create_case = COSMO_CLM2_tools.create_case:create_case',
                                            'cc2_control_case = COSMO_CLM2_tools.control_case:control_case']},
          install_requires=['f90nml>=1.0.2']
    )
  #+END_SRC

* Notes                                                            :noexport:
** DONE Enable COSMO only                                               :dev:
